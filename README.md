# 模块化开发 #

## 前言 ##

在讲模块化开发之前，我们先了解一个问题，javascript能做什么
从之前的表单验证到互联网广告泡沫被人诟骂，之间的心酸过程无人能了解，javascript被长期困在浏览器中，其实浏览器环境下的 JavaScript 和 它本身还是有很大区别的，浏览器下的 JavaScript 在 它整个体系中其实也只是很小（但很重要）的一部分而已。时光如梭，毕业已数十年，我等时常慨叹人生之残酷，种种无奈，经历风雨方能温柔成熟，这都是生活给与的。javascript何尝不是，已经进入富客户端、大前端时代。互联网产品的迭代，促进web前端飞速发展，PC、服务端开发、移动端、桌面应用、游戏、包括未来进军物联网时代，javascrpt已经到了令人瞩目的时候，组件化、框架化之路已经在火热奔跑在。不必害怕，不必彷徨，相信这个世界是你的。

以下是摘录对web前端重大影响

- Ajax技术的出现让前端可以在不刷新页面的情况下和后端进行数据交换

- jQuery/zepto让 JS 变得异常简单

- Bootstrap/Amaze UI 等 UI 框架更是让前端的成本无限降低

- requirejs/seajs让程序模块化开发，javscript也可以进行依赖管理

- MVVM框架的兴起前后端分离做到了极致

## 模块化驱动 ##
经历了后天的不断努力，javascript不断被内聚抽象，以便能更好的组织业务代码，从另一个角度看，也道出了javascipt缺失的一样东西，模块
服务端的语言，已经到了成熟稳定期，比如java/py/ruby/php都有自身的模块化机制，而javascript只有`<script>`方式引入代码，自身无组织和约束能力。
不得不利用语言本身特性，使用命名空间方式，人为约束代码，达到模块化开发的方便。
我们从一些大的厂子创造出来的框架就可以看到整个发展趋势，其中包括Dojo/ExtJS/YUI等。
从版本升级可以发现，他们的发展代表着语言的发展，从之前的命名空间方式模糊化，到现在的CommonJS规范。一步一步,繁荣富强。
真正让大前端，发现的起来的其实要归功于模块化 
需要了解命名空间方式模块化的去git这些框架，这里不再讲。今天主要介绍一下，CommonJS规范

## 模块化的价值 ##

要谈模块化，首先要知道模块化的意义，开门见山地说：

    代码复用
    提升维护性
就这么简单，别多想
## CommonJS ##
CommonJS规范是什么，可能会有人这么问，

说道CommonJS，CommonJS是服务器模块的规范，
CommonJS规范为javscript制定了一个美好的愿景，希望javascript能够在任何地方运行。任何地方。
javascript语言本身有很多缺陷，包括

- 没有模块系统
- 标准库缺少
- 没有标准接口
- 缺少包管理系统

CommonJS规范得提出，主要是为了弥补javascript的缺陷，这样就可以有开发大型应用的能力。目前nodejs采用了这个规范。
不过可能有些疑问，那AMD/CMD和他又有什么关系呢。
首先，commonJS是服务端规范，主要应用服务器的编程。不用考虑异步加载的方式。但是，但是如果是浏览器环境，要从服务端加载模块，这就必须采用异步模式，所以就有了AMD/CMD解决方案。
其实这样说比较合理，CMD和AMD都是CommonJS的一种规范的实现定义,著名代表就是RequireJS和SeaJS是对应的实践
CMD推崇依赖就近，AMD推崇依赖前置。留下来自己去研究。

我们来搞一下，CommonJS的例子：

    // a.js
    module.exports = function () {
    console.log('This is a.js');
    };
    //b.js
    var a = require('./a');
    a();
    console.log('This is b.js');
## AMD ##

RequireJS 在推广过程中对模块定义的规范化产出
AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。
AMD规范允许输出模块兼容CommonJS规范
例子：

    //AMD方式定义模块
    define(['dep1','dep2'],function(dep1,dep2){
     //内部只能使用制定的模块
      return function(){};
    });
    
## CMD ##
CMD是SeaJS 在推广过程中对模块定义的规范化产出

CMD是延迟执行

    //CMD
    define(function(require,exports,module){
       //此处如果需要某XX模块，可以引入
       var xx=require('XX');
    });
## UMD ##
UMD是AMD和CommonJS的糅合

因为:CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装

所以：人们又想出另一个更通用的模式UMD。希望解决跨平台的解决方案。

以上的模块化规范，需要使用的去找资料研究，这里不再做使用教程。也希望黑黑组织，后续会出这种简单使用级的文章。


## 模块化与工程化 ##


终于谈到了工程化，兴奋，模块化就是那样，为了方便开发，搞出来的，线下模块化开发，线上压缩合并打包，何乐而不为呢。锻炼自我，成就项目。

### 现状： ##
近几年我们也可以发现一些想象，和同行业的大牛也时常交流，前端的发展主要是依托互联网产品的发展，而有一部分群体，包括我，从事的是企业级的开发，
模块化开发国内的并不乐观，更别谈工程化。毕竟中小型企业的现状，实力不足，项目多，为了能短期收益，稳定、快速，安全，依然采用传统方式的开发。长叹一声，这也只是说说国内的现状。希望我们能驱动更好的发展。这里先把工程化的概念说说，使用不使用需要个人揣摩。

大部分时候我们谈的“工程化”其实只是“工具化”。
我们利用工具，可以在项目构建部署上，发挥很大作用。
### 工具 ##
- 构建工具 [gulp](http://www.gulpjs.com.cn/) 
- 静态分析工具 [webpack](http://webpack.github.io/)


### 总结

前端工程化相关问题是随之前端的发展越来越受到重视的问题，一套好的工程化解决方案能在提高开发效率(包括代码编写的舒适度及多人协作)的同时确保整个系统的伸缩性(各种不同的部署环境)及健壮性(安全)，同时在性能上又能有一个很优异的表现(主要上各种缓存策略加载策略等)，而且这套方案又应该是对工程师无感知(或感知很小)趋于自动化的一套方案。总知要达到这个目的前端工程化还有很长一段路要走。
